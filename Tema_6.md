# Тема 6. Базовые коллекции: словари, кортежи.

Отчёт по теме №6 выполнил:

- Хайрутдинов Игорь Юрьевич
- ИВТ-22-2

| Задание | Лаб_раб | Сам_раб |
| ------- | ------- | ------- |
| Задание 1 | + | + |
| Задание 2 | + | + |
| Задание 3 | + | + |
| Задание 4 | + | + |
| Задание 5 | + | + |

Работу проверил:

- к.э.н., доцент Панов М.А.

## Лабораторная работа №1
### В школе, где вы учились, узнали, что вы крутой программист, и попросили написать программу для учителей, которая будет при вводе кабинета писать для него ключ доступа и статус, занят кабинет или нет. При написании программы необходимо использовать словарь (dict), который на вход получает номер кабинета, а на выход выдаёт необходимую информацию. Если кабинета, который вы ввели, нет в словаре, то в консоль в виде значения ключа нужно вывести “None” и виде статуса вывести “False”. По большому счету, написав данную программу, мы с вами научились заменять иногда громоздкую конструкцию if/elif/else, поскольку здесь функционал словаря полностью повторяет функционал условия, но при этом у использования словарей в более сложных программах есть намного больше возможностей реализации.

```python
numOfOffice=int(input('№ кабинета: '))
dic={
    101: {'key': 5245, 'access': True},
    102: {'key': 7463, 'access': True},
    103: {'key': 6412, 'access': True},
    104: {'key': 9051, 'access': False},
    None: {'key': None, 'access': False}
}
info=dic.get(numOfOffice)
if not info: info=dic[None]
print(info.get('key'),info.get('access'))
```
### Результат
![скрин](https://github.com/a-arkham-3005/program_engineering/blob/Тема_6/screens/lab1.png)

## Выводы

Результат выполнения программы представлен на скриншоте выше.

## Лабораторная работа №2
### Алексей решил создать самый большой словарь в мире. Для этого он придумал функцию dict_maker (**kwargs), которая принимает неограниченное количество параметров «ключ: значение» и обновляет созданный им словарь my_dict, состоящий всего из одного элемента «first» со значением «so easy». Помогите Алексею создать данную функцию.

```python
from pprint import pprint
my_dict={'first':'so easy'}
def dict_maker(**kwargs):
    my_dict.update(**kwargs)
dict_maker(a1=1,a2=20,a3=54,a4=13)
dict_maker(name='Михаил',age=31,weight=70,eyes_color='blue')
pprint(my_dict)
```
### Результат
![скрин](https://github.com/a-arkham-3005/program_engineering/blob/Тема_6/screens/lab2.png)

## Выводы

Результаты выполнения программ представлены на скриншотах выше.

## Лабораторная работа №3
### Для решения некоторых задач бывает необходимо разложить строку на отдельные символы. Мы знаем, что это можно сделать при помощи split(), у которого более гибкая настройка для разделения для этого, но если нам нужно посимвольно разделить строку без всяких условий, то для этого мы можем использовать кортежи (tuple). Для этого напишем любую строку, которую будем делить и “обвернем” ее в tuple и дальше мы можем как нам угодно с ней работать, например, сделать ее списком (тогда получится полный аналог split()) или же работать с ним дальше, как с кортежем.

```python
input_string='HelloWorld'
result=tuple(input_string)
print(result)
print(list(result))
```
### Результат
![скрин](https://github.com/a-arkham-3005/program_engineering/blob/Тема_6/screens/lab3.png)

## Выводы

Результат выполнения программы представлен на скриншоте выше.

## Лабораторная работа №4
### Вовочка решил написать крутую функцию, которая будет писать имя, возраст и место работы, но при этом на вход этой функции будет поступать кортеж. Помогите Вовочке написать эту программу.

```python
def personal_info(name,age,company='NONAME'):
    print(f"Имя: {name}, Возраст: {age}, компания: {company}")
tom=("Григорий",22)
personal_info(*tom)
bob=("Георгий",41,"Яндекс")
personal_info(*bob)
```
### Результат
![скрин](https://github.com/a-arkham-3005/program_engineering/blob/Тема_6/screens/lab4.png)

## Выводы

Результат выполнения программы представлен на скриншоте выше.

## Лабораторная работа №5
### Для сопровождения первых лиц государства X нужен кортеж, но никто не может определиться с порядком машин, поэтому вам нужно написать функцию, которая будет сортировать кортеж, состоящий из целых чисел по возрастанию, и возвращает его. Если хотя бы один элемент не является целым числом, то функция возвращает исходный кортеж.

```python
def tuple_sort(tpl):
    for elm in tpl:
        if not isinstance(elm,int): return tpl
    return tuple(sorted(tpl))
if __name__=="__main__":
    print(tuple_sort((3,6,2,6,1,7,9,4,2,8)))
    print(tuple_sort(("O",12,5,1,5,0,1,4)))
```
### Результат
![скрин](https://github.com/a-arkham-3005/program_engineering/blob/Тема_6/screens/lab5.png)

## Выводы

Результат выполнения программы представлен на скриншоте выше.

## Самостоятельная работа №1
### При создании сайта у вас возникла потребность обрабатывать данные пользователя в странной форме, а потом переводить их в нужные вам форматы. Вы хотите принимать от пользователя последовательность чисел, разделенных пробелом, а после переформатировать эти данные в список и кортеж. Реализуйте вашу задумку. Для получения начальных данных используйте input(). Результатом программы будет выведенный список и кортеж из начальных данных.

```python
input_data=input("Введите числа через пробел: ")
inp_l=input_data.split(" ")
for el in range(len(inp_l)):
    inp_l[el]=int(inp_l[el])
inp_t=tuple(inp_l)
print(inp_l,inp_t,sep='\n')
```
### Результат
![скрин](https://github.com/a-arkham-3005/program_engineering/blob/Тема_6/screens/sam1.png)

## Выводы

Данная программа принимает строку в переменную input_data, затем создаёт список inp_l, разделяя значение input_data командой `split()` со знаком пробела в качестве аргумента, получая таким образом список из строковых значений, которые были разделены пробелом в исходной строке input_data. Затем в цикле идёт перебор по индексам до конца списка (до длины списка не включительно). В цикле значения в списке по индексам преобразовываются в числа (если какое-то значение - не число, выводится ValueError). Затем на основе списка inp_l командой `tuple()` с аргументом inp_l создаётся кортеж inp_t. В конце программа выводит список inp_l и кортеж inp_t через разрыв строки. Пример выполнения программы представлен на скриншоте выше.

## Самостоятельная работа №2
### Николай знает, что кортежи являются неизменяемыми, но он очень упрямый и всегда хочет доказать, что он прав. Студент решил создать функцию, которая будет удалять первое появление определенного элемента из кортежа по значению и возвращать кортеж без него. Попробуйте повторить шедевр не признающего авторитеты начинающего программиста. Но учтите, что Николай не всегда уверен в наличии элемента в кортеже (в этом случае кортеж вернется функцией в исходном виде). Входные данные: (1, 2, 3), 1); (1, 2, 3, 1, 2, 3, 4, 5, 2, 3, 4, 2, 4, 2), 3); (2, 4, 6, 6, 4, 2), 9). Ожидаемый результат: (2, 3); (1, 2, 1, 2, 3, 4, 5, 2, 3, 4, 2, 4, 2); (2, 4, 6, 6, 4, 2).

```python
def tuple_filter(tup,v):
    if not tup.__contains__(v): return tup
    else:
        ind=tup.index(v)
        if ind==0: return tup[1:]
        elif ind==len(tup)-1: return tup[:-1]
        else: return tup[0:ind]+tup[ind+1:]

if __name__=="__main__":
    print(tuple_filter((1,2,3),1))
    print(tuple_filter((1,2,3,1,2,3,4,5,2,3,4,2,4,2), 3))
    print(tuple_filter((2,4,6,6,4,2), 9))
```
### Результат
![скрин](https://github.com/a-arkham-3005/program_engineering/blob/Тема_6/screens/sam2.png)

## Выводы

Данный код содержит функцию tuple_filter, принимающую два аргумента в параметры tup и v. Первый представляет собой кортеж, второй - обычную переменную. В функции проверяется через `__contains__()`, существует ли в кортеже tup элемент v, и если в кортеже его нет, функция возвращает кортеж tup и завершает работу. Иначе индекс первого попавшегося элемента v в кортеже tup записывается в переменную ind, а дальше идёт проверка, является ли индекс ind одним из крайних значений, или же нет. Если индекс равен 0 (первое совдадение по v в начале), возвращается срез кортежа со второго элемента с индексом 1 до конца кортежа. Если же индекс - длина массива минус 1 (первое и единственное совпадение по v в конце кортежа), возвращается срез кортежа с начала до последнего элемента не включительно. Иначе возвращается результат конкатенации из двух срезов кортежа: с начала до индекса ind не включительно и с индекса ind+1 до конца кортежа. Сама функция вызывается через точку входа `__main__` с входными данными по заданию: (1, 2, 3), 1; (1, 2, 3, 1, 2, 3, 4, 5, 2, 3, 4, 2, 4, 2), 3; (2, 4, 6, 6, 4, 2), 9. Результат выполнения программы представлен на скриншоте выше - первое совпадение по значению "удаляется" из кортежа с помощью функции `tuple_filter()`.

## Самостоятельная работа №3
### Ребята поспорили, кто из них одним нажатием на numpad наберет больше повторяющихся цифр, но не понимают, как узнать победителя. Вам им нужно в этом помочь. Дана строка в виде случайной последовательности чисел от 0 до 9 (длина строки минимум 15 символов). Требуется создать словарь, который в качестве ключей будет принимать данные числа (т. е. ключи будут типом int), а в качестве значений – количество этих чисел в имеющейся последовательности. Для построения словаря создайте функцию, принимающую строку из цифр. Функция должна возвратить словарь из 3-х самых часто встречаемых чисел, также эти значения нужно вывести в порядке возрастания ключа.

```python
def dict_builder(line):
    nums = line.split(" ")
    for el in range(len(nums)):
        nums[el] = int(nums[el])
    dic = {}
    for i in nums:
        if not dic.__contains__(i):
            dic.update({i: 1})
        else:
            dic[i] += 1
    temp = sorted(dic.items(), key=lambda x: (-x[1], x[0]))
    dic = dict(temp[:3])
    return dic
if __name__=="__main__":
    line = input("Введите числа через пробел. ")
    print(dict_builder(line))
```
### Результат
![скрин](https://github.com/a-arkham-3005/program_engineering/blob/Тема_6/screens/sam3.png)

## Выводы

Данная программа содержит функцию `dict_builder()`, которая принимает аргумент в параметр line, затем создаёт список nums, разделяя значение line командой `split()` со знаком пробела в качестве аргумента, получая таким образом список из строковых значений, которые были разделены пробелом в исходной строке line. Затем в цикле идёт перебор по индексам до конца списка (до длины списка не включительно). В цикле значения в списке по индексам преобразовываются в числа (если какое-то значение - не число, выводится ValueError). После этого создаётся пустой словарь dic. Далее идёт перебор из списка nums, но уже по значениям, каждое из которых копируется в переменную i. Если словарь ещё не содержит значение по ключу i, то оно добавляется через `update()` с аргументом-словарём из одного элемента i со значением 1. Иначе к значению по ключу i в словаре dic прибавляется 1. Далее с помощью функции `items()` создаётся из получившегося словаря список из кортежей, в которых первый элемент - ключ, а второй - значение. Он же поступает в функцию сортировки списков `sorted()` как первый из аргументов. Второй аргумент (key) указывает на параметры сортировки, которые поступают через lambda-функцию: сначала сортировка идёт по значению, о чём говорит индекс 1, в порядке убывания, о чём говорит минус перед параметром, затем по ключу - индекс 0. Оба параметра объединены в кортеж как выходные данные lambda-функции. Таким образом, получается список из словаря, отсортированный по значению в порядке убывания и по ключу в порядке возрастания. Из этого списка вновь строится словарь и прописывается как dic вместо ранее созданного словаря через функцию `dict()`, но берутся только первые три значения списка, о чём свидетельствует срез `temp[:3]`. Получившийся словарь dic выводится как выходное значение функции. Сама функция вызывается через точку входа `__main__` с входными данными, предоставленными пользователем, внутри команды вывода `print()`. Пример выполнения программы представлен на скриншоте выше.

## Самостоятельная работа №4
### Ваш хороший друг владеет офисом со входом по электронным картам, ему нужно чтобы вы написали программу, которая показывала в каком порядке сотрудники входили и выходили из офиса. Определение сотрудника происходит по id. Напишите функцию, которая на вход принимает кортеж и случайный элемент (id), его можно придумать самостоятельно. Требуется вернуть новый кортеж, начинающийся с первого появления элемента в нем и заканчивающийся вторым его появлением включительно. Если элемента нет вовсе – вернуть пустой кортеж. Если элемент встречается только один раз, то вернуть кортеж, который начинается с него и идет до конца исходного. Входные данные: (1, 2, 3), 8); (1, 8, 3, 4, 8, 8, 9, 2), 8); (1, 2, 8, 5, 1, 2, 9), 8). Ожидаемый результат: (); (8, 3, 4, 8); (8, 5, 1, 2, 9).

```python
def between1stand2nd(tup,n):
    inds=[]
    for i in range(len(tup)):
        if tup[i]==n: inds.append(i)
        if len(inds)==2: break
    if len(inds)==0: return ()
    elif len(inds)==1: return tup[inds[0]:]
    else: return tup[inds[0]:inds[1]+1]
if __name__=="__main__":
    print(between1stand2nd((1,2,3),8))
    print(between1stand2nd((1,8,3,4,8,8,9,2),8))
    print(between1stand2nd((1,2,8,5,1,2,9),8))
```
### Результат
![скрин](https://github.com/a-arkham-3005/program_engineering/blob/Тема_6/screens/sam4.png)

## Выводы

Данный код содержит функцию `between1stand2nd()`, принимающую на вход кортеж tup и переменную n. В ней сначала создаётся пустой список inds, который будет содержать индексы различных вхождений элемента n в кортеже tup, что проверяется циклом далее с перебором по индексам до конца кортежа (через `len()`). При переборе по индексам, если элемент в кортеже под этим индексом совпадает с n, этот индекс добавляется в список inds. Если нашлись два индекса для первых 2 вхождений элемента n в кортеже tup, цикл обрывается через tup. Далее идёт проверка по количеству значений в списке inds: если значений нет (значения n попросту нет в кортеже tup), выводится пустой кортеж как ответ; а если значение одно, то выводится срез кортежа, начиная с этого индекса до конца. Иначе же выводится срез кортежа с первого значения inds до второго значения этого же списка, т.е. от первого совпадения по n до второго. `inds[1]+1` означает, что срез идёт до следующего индекса за вторым совпадением, так как срез в Python идёт от первого параметра включительно до второго, не включительно. После функции идёт точка входа `__main__`: этот код выполняется при запуске этого кода как программы. В нашем случае - это вызов функции between1stand2nd по трём парам параметров, указанных в условии, и вывод значения в консоль. Результат совпадает с ожидаемым. А сам результат выполнения программы представлен на скриншоте выше.

## Самостоятельная работа №5
### Напишите программу, которая будет через функцию "удалять" из кортежа все значения, совпадающие по n, через срезы по индексам и конкатенацию, без преобразования в список. Если значений по n нет - выводить кортеж "как есть".

```python
def filter_tuple(tup,n):
    indexes=[]
    for i in range(len(tup)):
        if tup[i]==n: indexes.append(i)
    if len(indexes)==0: return tup
    out=()
    for i in range(len(indexes)):
        if i==0 and indexes[i]!=0: out+=tup[:indexes[i]]
        elif i==len(indexes)-1 and indexes[i]!=len(tup)-1: out+=tup[indexes[i]+1:]
        elif i==len(indexes)-1: break
        else: out+=tup[indexes[i]+1:indexes[i+1]]
    return out
if __name__=="__main__":
    print(filter_tuple((2,3,2,4,2),2275))
    print(filter_tuple((4,5,6,4,4,3,4),4))
    print(filter_tuple((5,6,7,4),4))
```
### Результат
![скрин](https://github.com/a-arkham-3005/program_engineering/blob/Тема_6/screens/sam5.png)

## Выводы

Данный код содержит функцию filter_tuple, которая принимает на вход кортеж tup и обычное значение в параметр n. В функции создаётся, как и в коде из сам. раб. №4, список для индексов по совпадениям, но в отличие от случая из сам. раб. №4, этот список не ограничен 2 элементами. В цикле просто добавляются индексы всех совпадений в кортеже по n через `append()`. Если список индексов пустой, то кортеж возвращается как есть. Иначе создаётся пустой кортеж out, а далее идёт перебор по индексам, но уже в списке indexes. Если это первая итерация, и первый индекс не равен 0 (т.е. первое совпадение не в начале), то к кортежу out конкатенируется срез кортежа tup с начала до индекса `indexes[i]` не включительно. Если же это последняя итерация (с индексом `len(indexes)-1`), то если последнее совпадение находится не в конце кортежа (т.е. индекс `indexes[i]` не равен длине tup минус 1), то к кортежу out прибавляется срез tup с индекса, следующего за `indexes[i]`, до конца. Иначе, если последнее совпадение всё же находится в конце, оно игнорируется, и цикл завершается. Если же либо это первая итерация, при том что первый индекс из indexes всё же равен 0 (первое совпадение в начале), либо это итерация, которая не является первой или последней, то к out прибавляется срез tup от индекса, следующего за `indexes[i]`, до индекса `indexes[i+1]` не включительно. Получившийся кортеж out выводится как выходное значение функции. Сама программа запускается через точку входа "__main__". В ней выводятся через вышеупомянутую функцию значения кортежей (2,3,2,4,2) за вычетом значений 2275, (4,5,6,4,4,3,4) за вычетом значений 4 и (5,6,7,4) за вычетом 4. Результат работы соответствует заявленному и представлен на скриншоте выше.

## Общие выводы по теме

В рамках данной темы мы изучили:

1. Сущность словарей, создание словарей через фигурные скобки, ключ и значение или через функцию dict со списком кортежей из двух значений;

2. Обращение к значениям словаря по ключу;

3. Объединение словарей через `update()`;

3. Разбиение словаря на список кортежей через `items()`;

4. Сущность кортежей, обращение к элементам, разбиение строки на символы в кортеже, создание кортежа через `tuple()` и списка через `list()`;

5. Передачу кортежа и словаря как аргументы функции;

6. Срезы кортежей, конкатенация кортежей через знак "+";

7. Сортировку списков по нескольким критериям через параметр key с передачей в него кортежа по lambda-функции.

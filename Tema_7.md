# Тема 7. Работа с файлами (ввод, вывод).

Отчёт по теме №7 выполнил:

- Хайрутдинов Игорь Юрьевич
- ИВТ-22-2

| Задание | Лаб_раб | Сам_раб |
| ------- | ------- | ------- |
| Задание 1 | + | + |
| Задание 2 | + | + |
| Задание 3 | + | + |
| Задание 4 | + | + |
| Задание 5 | + | + |
| Задание 6 | + | - |
| Задание 7 | + | - |
| Задание 8 | + | - |
| Задание 9 | + | - |
| Задание 10 | + | - |

Работу проверил:

- к.э.н., доцент Панов М.А.

## Лабораторная работа №1
### Составьте текстовый файл и положите его в одну директорию с программой на Python. Текстовый файл должен состоять минимум из 2 строк.

```python
pass
```
### Результат
![скрин](https://github.com/a-arkham-3005/program_engineering/blob/Тема_7/screens/lab1.png)

## Выводы

Текстовый файл создан и помещён в папку с программой, как на скриншоте выше.

## Лабораторная работа №2
### Напишите программу, которая выведет только первую строку из вашего файла, при этом используйте конструкцию open()/close().

```python
f=open('input.txt','r')
print(f.readline())
f.close()
```
### Результат
![скрин](https://github.com/a-arkham-3005/program_engineering/blob/Тема_7/screens/lab2.png)

## Выводы

Результат выполнения программы представлен на скриншоте выше.

## Лабораторная работа №3
### Напишите программу, которая выведет все строки из вашего файла в массиве, при этом используйте конструкцию open()/close().

```python
f=open('input.txt','r')
print(f.readlines())
f.close()
```
### Результат
![скрин](https://github.com/a-arkham-3005/program_engineering/blob/Тема_7/screens/lab3.png)

## Выводы

Результат выполнения программы представлен на скриншоте выше.

## Лабораторная работа №4
### Напишите программу, которая выведет все строки из вашего файла в массиве, при этом используйте конструкцию with open().

```python
with open('input.txt','r') as f: print(f.readlines())
```
### Результат
![скрин](https://github.com/a-arkham-3005/program_engineering/blob/Тема_7/screens/lab4.png)

## Выводы

Результат выполнения программы представлен на скриншоте выше.

## Лабораторная работа №5
### Напишите программу, которая выведет каждую строку из вашего файла отдельно, при этом используйте конструкцию with open().

```python
with open('input.txt','r') as f:
    for i in f.readlines(): print(i)
```
### Результат
![скрин](https://github.com/a-arkham-3005/program_engineering/blob/Тема_7/screens/lab5.png)

## Выводы

Результат выполнения программы представлен на скриншоте выше.

## Лабораторная работа №6
### Напишите программу, которая будет добавлять новую строку в ваш файл, а потом выведет полученный результат в консоль. Вывод можно осуществлять любым способом. Обязательно проверьте сам файл, чтобы изменения в нём тоже отображались.

```python
with open('input.txt','a+') as f:
    f.write("\nThis is added by main.py.")
with open('input.txt','r') as f:
    print(f.readlines())
```
### Результат
![скрин](https://github.com/a-arkham-3005/program_engineering/blob/Тема_7/screens/lab6.png)
![файл](https://github.com/a-arkham-3005/program_engineering/blob/Тема_7/screens/lab6f.png)

## Выводы

Результат выполнения программы представлен на скриншотах выше (вывод и изменённый файл).

## Лабораторная работа №7
### Напишите программу, которая перепишет всю информацию, которая была у вас в файле до этого, например, напишет любые данные из произвольно составленного вами списка. Также не забудьте проверить, что изменённая вами информация сохранилась в файле.

```python
with open('input.txt','w') as f:
    for i in ['a','b','c']:
        f.write('\n'+i+')')
    print('Overwritten')
```
### Результат
![скрин](https://github.com/a-arkham-3005/program_engineering/blob/Тема_7/screens/lab7.png)
![файл](https://github.com/a-arkham-3005/program_engineering/blob/Тема_7/screens/lab7f.png)

## Выводы

Результат выполнения программы представлен на скриншотах выше (вывод и изменённый файл).

## Лабораторная работа №8
### Выберите любую папку на своём компьютере, имеющую вложенные директории. Вывелите на печать в терминал её содержимое, как и всех подкаталогов, при помощи функции print_docs(directory).

```python
import os
def print_docs(directory):
    listi=os.walk(directory)
    for i in listi:
        print(f"Папка {i[0]} содержит:")
        print(f"Папки: {",".join([j for j in i[1]])}")
        print(f"Файлы: {",".join([j for j in i[2]])}")
        print('-'*40)
if __name__=="__main__":
    print_docs(os.environ['userprofile']+'\\Pictures')
```
### Результат
![скрин](https://github.com/a-arkham-3005/program_engineering/blob/Тема_7/screens/lab8.png)

## Выводы

Результат выполнения программы представлен на скриншоте выше.

## Лабораторная работа №9
### Документ "input.txt" содержит следующий текст: Приветствие; Спасибо; Извините; Пожалуйста; До свидания; Ты готов?; Как дела?; С днём рождения!; Удача!; Я тебя люблю. Требуется реализовать функцию, которая выводит слово, имеющее максимальную длину (или список слов, если таковых несколько). Проверьте работоспособность программы на своём наборе данных.

```python
def longword(fil):
    with open(fil,encoding='utf-8') as f:
        wordz=f.read().split()
        maxLen=len(max(wordz,key=len))
        sought=[]
        for w in wordz:
            if len(w)==maxLen: sought.append(w)
        if len(sought)==1: return sought[0]
        return sought
print(longword('input.txt'))
```
### Результат
![скрин](https://github.com/a-arkham-3005/program_engineering/blob/Тема_7/screens/lab9.png)
![файл](https://github.com/a-arkham-3005/program_engineering/blob/Тема_7/screens/lab9f.png)

## Выводы

Результат выполнения программы представлен на скриншотах выше (вывод и исходный файл).

## Лабораторная работа №10
### Требуется создать csv-файл "rows_300.csv" со следующими столбцами: №-номер по порядку (от 1 до 300), секунда-текущая секунда на вашем ПК, микросекунда - текущая миллисекунда на часах. Для наглядности на каждой итерации цикла искусственно приостанавливайте скрипт на 0,01 сек.

```python
import csv,datetime as dt,time
with open('rows_300.csv','w',encoding='utf-8',newline='') as f:
    writer=csv.writer(f)
    writer.writerow(['№','Секунда','Микросекунда'])
    for line in range(300):
        writer.writerow([line+1,dt.datetime.now().second,dt.datetime.now().microsecond])
        time.sleep(0.01)
```
### Результат
![скрин](https://github.com/a-arkham-3005/program_engineering/blob/Тема_7/screens/lab10.png)
![файл](https://github.com/a-arkham-3005/program_engineering/blob/Тема_7/screens/lab10f.png)

## Выводы

Результат выполнения программы представлен на скриншотах выше (вывод и полученный файл).

## Самостоятельная работа №1
### Найдите в интернете любую статью (объем статьи не менее 200 слов), скопируйте ее содержимое в файл и напишите программу, которая считает количество слов в текстовом файле и определит самое часто встречающееся слово. Результатом выполнения задачи будет: скриншот файла со статьей, листинг кода, и вывод в консоль, в котором будет указана вся необходимая информация.

```python
with open('article.txt','r') as f:
    words=f.read().split()
    numOfWords=len(words)
    maxWordCount=max([words.count(i) for i in words])
    maxWord=''
    for i in words:
        if words.count(i)==maxWordCount: maxWord=i
    print(f"Самое часто встречаемое слово в статье - {maxWord}, встречается {maxWordCount} раз(а). Всего слов - {numOfWords}.")
```
### Результат
![скрин](https://github.com/a-arkham-3005/program_engineering/blob/Тема_7/screens/sam1.png)
![статья](https://github.com/a-arkham-3005/program_engineering/blob/Тема_7/screens/sam1_art.png)

## Выводы

Код в данной программе выполняется лишь при успешном открытии файла article.txt, который находится рядом с файлом программы. Об этом свидетельствует то, что весь код находится в конструкции `with open('article.txt','r') as f`. При отсутствии файла, доступа к файлу или по другим причинам неуспешного открытия файла выводится сообщение об ошибке. Сам файл открыт в режиме чтения, о чём говорит параметр 'r' после имени файла, доступ к файлу осуществляется через переменную f, после конструкции (в нашем случае - в конце программы) файл закрывается автоматически и память освобождается. После открытия файл читается программой целиком (функция `read()`), затем содержимое, представленное в виде строки, разделяется на отдельные слова командой `split()` и записывается в память как список с именем words. Далее подсчитывается длина этого списка через `len()` и записывается в переменную numOfWords. Затем список прогоняется в цикле по элементам, находится количество совпадений в списке по каждому элементу и находится максимальное значение количества совпадений по элементу, которое записывается в переменную maxWordCount. После этого создаётся пустая строковая переменная maxWord, а список words прогоняется в цикле ещё раз, и ещё раз находится количество совпадений в списке по каждому элементу. Если это количество совпадает с максимальным (переменная maxWordCount), то переменная maxWord перезаписывается на текущее значение. Далее просто выводится в консоль строка "Самое часто встречаемое слово в статье - {maxWord}, встречается {maxWordCount} раз(а). Всего слов - {numOfWords}." с подстановкой соответствующих значений переменных. В нашем случае со статьёй, скриншот которой находится выше, вышло всего 201 слово и самое встречаемое из них - Windows, которое встречается 11 раз. Результат выполнения программы также представлен на скриншоте выше.

## Самостоятельная работа №2
### У вас появилась потребность в ведении книги расходов. Посмотрев все существующие варианты, вы пришли к выводу, что вас ничего не устраивает и нужно все делать самому. Напишите программу для учета расходов. Программа должна позволять вводить информацию о расходах, сохранять ее в файл и выводить существующие данные в консоль. Ввод информации происходит через консоль. Результатом выполнения задачи будет: скриншот файла с учетом расходов, листинг кода, и вывод в консоль, с демонстрацией работоспособности программы.

```python
while True:
    req=input("Нужно ли вам вводить новые расходы? (0 - нет, любой другой ответ - да) ")
    if req=='0': break
    category=input("Категория расходов: ")
    number=int(input("Сумма расходов по этой категории: "))
    try:
        with open('outcomes.txt','a') as f:
            f.write(category+"\t"+str(number)+"\n")
    except FileNotFoundError:
        with open('outcomes.txt','x') as f:
            f.write(category+"\t"+str(number)+"\n")
try:
    with open('outcomes.txt','r') as f:
        print("Список расходов:")
        for i in f.readlines():
            print(i.strip("\n"))
except FileNotFoundError:
    print("Файл с расходами не найден! Запишите новые расходы.")
```
### Результат
![скрин](https://github.com/a-arkham-3005/program_engineering/blob/Тема_7/screens/sam2.png)
![файл](https://github.com/a-arkham-3005/program_engineering/blob/Тема_7/screens/sam2f.png)

## Выводы

Данная программа состоит из двух частей. Первая часть - ввод данных - осуществляется в цикле без условия. В цикле сначала у пользователя спрашивается, нужно ли ему вводить данные о расходах. Вводимый ответ записывается в переменную req, и если её значение равно строке '0', то происходит выход из цикла во вторую часть программы. При любом другом ответе тело цикла выполняется дальше до следующей итерации. У пользователя спрашивается категория расходов и сумма расходов, данные записываются соответственно в переменные category и number, причём в первую записывается строка, а во вторую - число (на что указывает `input()` внутри `int()`). Далее программа пытается открыть файл outcomes.txt в режиме добавления (параметр 'a'), и если программа его не находит в директории с программой (т.е. выбрасывается исключение FileNotFoundError), то файл открывается в режиме эксклюзивной записи (параметр 'x'), позволяющий его создать. Выполнение программы в штатном режиме и при выбросе исключения здесь реализовано через конструкцию `try: - except FileNotFoundError:`. В любом случае в файл записывается командой `write()` строка со значениями переменных category и number, разделенных знаком табуляции, затем цикл начинается заново. После того, как пользователь выйдет из цикла, начнётся вторая часть программы - вывод данных в консоль. Программа попытается открыть файл outcomes.txt, но уже в режиме чтения, и если это удаётся, то выводится строка "Список расходов:", а за ней построчно выводится содержимое файла. Иначе выводится сообщение об ошибке "Файл с расходами не найден! Запишите новые расходы.", и программа закрывается. Пример выполнения программы представлен на скриншотах выше (вывод в консоль и файл outcomes.txt).

## Самостоятельная работа №3
### Имеется файл input.txt с текстом на латинице. Напишите программу, которая выводит следующую статистику по тексту: количество букв латинского алфавита; число слов; число строк. Текст в файле: Beautiful is better than ugly. Explicit is better than implicit. Simple is better than complex. Complex is better than complicated. Ожидаемый результат: Input file contains: 108 letters 20 words 4 lines

```python
with open('input.txt','r') as f:
    lines=f.readlines()
    numOfLines=len(lines)
    numOfWords=sum([len(i.split()) for i in lines])
    numOfLetters=0
    letters=[chr(i) for i in range(ord('A'),ord('Z')+1)]+[chr(i) for i in range(ord('a'),ord('z')+1)]
    for i in lines:
        for j in i.split():
            for k in j:
                if k in letters: numOfLetters+=1
	print("Input file contains:")
    print(numOfLetters,"letters")
    print(numOfWords,"words")
    print(numOfLines,"lines")
```
### Результат
![скрин](https://github.com/a-arkham-3005/program_engineering/blob/Тема_7/screens/sam3.png)

## Выводы

Код в данной программе выполняется лишь при успешном открытии файла input.txt, который находится рядом с файлом программы. При возникновении ошибки открытия файла выводится сообщение об ошибке и программа завершается. Сам файл открывается в режиме чтения. После успешного открытия файла его содержимое читается программой и заносится как список строк с названием lines (командой `readlines()`). Количество элементов в этом списке записывается в переменную numOfLines. Далее список прогоняется по элементам, которые в свою очередь разделяются на списки слов командой `split()`. У каждого такого списка находится количество элементов (это будет количество слов в строке), и все эти количества суммируются, а сумма заносится в переменную numOfWords. Для подсчёта количества букв сначала создаётся переменная numOfLetters со значением 0 и список letters, содержащий заглавные и строчные буквы латинского алфавита. Для создания такого списка используются функции `ord()` и `chr()`, по назначению противоположные друг другу: первая возвращает символ в таблице ASCII по его номеру, вторая наоборот - выводит номер заданного символа в таблице ASCII, и список чисел, создаваемый через `range()`. Далее список list прогоняется по элементам в цикле (строкам из файла), который содержит вложенный цикл, прогоняемый по списку слов из каждой строки. Каждое слово прогоняется посимвольно (строка представляет собой кортеж в Python). Для разных частей файла используются разные переменные: i - для строк, j - для слов, k - для символов. Каждый символ проверяется на наличие в списке letters, и если это - буква латинского алфавита, то переменная numOfLetters увеличивается на 1. После всех циклов выводится строка "Input file contains:", а за ней - сначала значение numOfLetters со словом "letters" в конце, затем значение numOfWords со словом "words", и наконец, значение numOfLines со словом "lines". Вывод совпал с ожидаемым при данных в условии исходных данных. Результат выполнения программы представлен на скриншоте выше.

## Самостоятельная работа №4
### Напишите программу, которая получает на вход предложение, выводит его в терминал, заменяя все запрещенные слова звёздочками * (количество звездочек равно количеству букв в слове). Запрещенные слова, разделенные символом пробела, хранятся в текстовом файле input.txt. Все слова в этом файле записаны в нижнем регистре. Программа должна заменить запрещенные слова, где бы они ни встречались, даже в середине другого слова. Замена производится независимо от регистра: если файл input.txt содержит запрещенное слово exam, то слова exam, Exam, ExaM, EXAM и exAm должны быть заменены на ****. Запрещенные слова: hello email python the exam wor is Предложение для проверки: Hello, world! Python IS the programming language of thE future. My EMAIL is.... PYTHON is awesome!!!! Ожидаемый результат: *****, ***ld! ****** ** *** programming language of *** future. My ***** **.... ****** ** awesome!!!!

```python
import re
with open('input.txt','r') as f:
    banned=f.readline().strip().split()
    censor=['*'*len(i) for i in banned]
    sentence="Hello, world! Python IS the programming language of thE future. My EMAIL is.... PYTHON is awesome!!!!"
    for i in range(len(banned)):
        sentence=re.sub(banned[i],censor[i],sentence,flags=re.IGNORECASE)
    print(sentence)
```
### Результат
![скрин](https://github.com/a-arkham-3005/program_engineering/blob/Тема_7/screens/sam4.png)
![файл](https://github.com/a-arkham-3005/program_engineering/blob/Тема_7/screens/sam4f.png)

## Выводы

Для выполнения данной программы подключена библиотека re, отвечающая за регулярные выражения (regular expressions). Это нужно для регистронезависимой замены строк. Код программы выполняется только при успешном открытии файла input.txt. После открытия файла из его содержимого читается первая строка, она же разделяется на слова, из которых исключены символы по типу разрыва строки (командой `strip()`), затем слова записываются в список banned. После этого создаётся список censor для указания на то, на что должны заменяться значения списка banned с соответствующими индексами. Для этого список banned прогоняется по элементам, находится длина каждого элемента, затем символ `*` умножается на это количество, таким образом создавая список из строк, содержащих ровно столько звездочек, сколько содержится символов в каждом значении списка banned с соответствующим индексом. После создания списков в переменную sentence заносится исходное предложение из условия: "Hello, world! Python IS the programming language of thE future. My EMAIL is.... PYTHON is awesome!!!!". Далее список banned прогоняется по индексам, о чём свидетельствуют вложенные команды `range(len())`, каждый индекс записывается в переменную i. Затем с помощью функции `sub()` из модуля re, импортированного в начале программы, производится замена в строке sentence каждой строки из списка banned на строку из списка censor с тем же индексом. Замена производится с использованием флага `re.IGNORECASE`, позволяющий функции `sub()` производить замену без учёта регистра символов. Новое значение после каждой такой замены перезаписывает старое в переменной sentence. После всех замен значение sentence выводится на экран. Результат выполнения программы совпал с ожидаемым, и он показан на скриншоте выше, вместе со скриншотом файла исходных данных.

## Самостоятельная работа №5
### Напишите программу, которая будет копировать содержимое одного текстового файла, путь к которому указывает пользователь, в другой файл с перезаписью старого содержимого и преобразованием кодировки из UTF-8 в Windows-1251.

```python
data=''
file_open=False
name1=input("Путь до файла: ")
name2=input("Куда копировать? ")
try:
    with open(name1,'r',encoding='utf-8') as f:
        data=f.read()
        file_open=True
except FileNotFoundError:
    print("Файл не найден!")
if file_open:
    try:
        with open(name2, 'x', encoding='windows-1251') as f:
            f.write(data)
    except FileExistsError:
        with open(name2, 'w', encoding='windows-1251') as f:
            f.write(data)
```
### Результат
![скрин](https://github.com/a-arkham-3005/program_engineering/blob/Тема_7/screens/sam5.png)
![файл1](https://github.com/a-arkham-3005/program_engineering/blob/Тема_7/screens/sam5f.png)
![файл2](https://github.com/a-arkham-3005/program_engineering/blob/Тема_7/screens/sam5f1.png)

## Выводы

Данная программа в самом начале создаёт пустую переменную data и флаговую переменную file_open со значением по умолчанию False (файл не открыт), с помощью которой программа определяет, открыт ли исходный файл успешно или же нет. Далее у пользователя спрашивается, какой файл копировать (путь до него сохраняется в переменную name1) и куда (путь сохраняется в переменную name2). Затем программа попытается открыть файл по пути name1 в режиме чтения в кодировке UTF-8 (о чём говорит соответствующий параметр encoding), и если это удалось, то в переменную data записывается содержимое этого файла, а переменная file_open меняет значение на True. Если же файла по пути name1 нет, то выводится сообщение об ошибке "Файл не найден!". Дальнейшие действия зависят от значения переменной file_open: если она равна всё так же False, программа завершается. Иначе же программа попытается открыть файл по пути name2 в режиме эксклюзивной записи в кодировке Windows-1251. Если файл уже существует и выбрасывается соответствующее исключение, то этот же файл открывается в режиме перезаписи (параметр 'w') в той же кодировке. В любом случае значение переменной data, в которую записано содержимое файла по пути name1, записывается в файл по пути name2 с перезаписью старого содержимого, если файл уже существует, после этого программа завершается. Пример выполнения программы - вывод на консоль, исходный файл и получившийся файл с кодировками оных - представлен на скриншотах выше.

## Общие выводы по теме

В рамках данной темы мы изучили:

1. Конструкции `open()`-`close()` и `with open()` для открытия и закрытия файлов;

2. Способы чтения файлов: команды `read()`, `readline()` и `readlines()`;

3. Различные режимы открытия файла (чтение, перезапись, добавление, эксклюзивное добавление, чтение и запись), параметры открытия файла - кодировка, символ переноса строки;

4. Команду для записи данных в файл `write()`;

5. Работу с каталогами и переменными среды операционной системы с помощью модуля os;

6. Модуль csv для работы с файлами одноимённого типа;

7. Конструкцию `try: - except Exception:` для обработки исключений.
